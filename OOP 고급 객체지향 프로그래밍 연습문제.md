## 1장

1. 소프트웨어 복잡도로 머신러닝과 같은 방법 등이 보편화되고 있다, 높은 비용으로 개발 비용 등이 높아지고 있다.
2. 80년대에는 객체지향 프로그래밍이 보급되었고, 90년대에 객체 지향 분석 및 설계가 개발되었다.
3. 1
4. 1
5. 1
6. 1
7. 1
8. 1
9. 1
10. 1

---

## 2장

1. X
2. 속성 처리에 필요한 오퍼레이션을 내부에 포함하면서 독립성이 높고 복잡한 프로그램도 객체 단위로 나누어 개발할 수 있다.
3. 속성의 값이 변경되면 객체의 상태도 변경된다.
4. 대부분의 객체 속성은 그 객체의 기능성에 의해서만 처리된다.
5. 한 프로그램 세션 동안 유효하다, 세션이 종료되면 식별자가 모든 상태 정보와 같이 사라진다.
6. 1
7. 1
8. `비즈니스 프로세스의 결과를 물리적 객체에 저장하지 않고, 대부분 개념적 객체에 저장하는 이유는 무엇인가?`
9. 물리적 객체가 더 많다. 대부분 물리적 객체를 여러 개 사용하여 처리한 결과가 개념적 객체에 저장되기 때문이다.

---

## 3장

1. X
2. X
3. `한 객체 안에 관련된 속성 또는 오퍼레이션이 일부 누락되어 정의되었다면 어떤 문제가 발생하는지 쓰시오.`
4. 
5. 
6. Getter, Setter는 감추어진 속성에 간접적으로 접근할 때 사용한다. `private int x;`

    데이터 처리의 CRUD는 어떤 속성/데이터에 대한 처리에서 사용한다. `PhoneNumber`

    비즈니스 고유의 오퍼레이션은 그 객체 고유의 기능을 처리한다. `Car Rental System에서 checkOutCar();`

    객체의 생명주기 처리 오퍼레이션은 객체를 생성하고, 삭제하고, 미들웨어에서 인스턴스를 관리한다.

    객체의 영구성 관리 오퍼레이션은 데이터베이스에 접근하여 객체의 상태를 저장하고, 객체를 불러온다.

7. 
8. 관련 속성과 오퍼레이션을 한 캡슐에 잘 보관하면, 수정 대상이 되는 특정 객체만 수정하면 되기 때문이다.

---

## 4장

1. 오퍼레이션을 public으로 공개해야 속성에 접근하여 속성을 변경할 수 있기 때문이다. 또한 오퍼레이션을 public으로 공개하여도 내부 알고리즘과 코드는 노출되지 않는다.
2. 객체의 속성값에 유효성 문제가 전혀 없을 것이라 생각하는 경우이다.
3. 객체 내부에서만 사용하는 오퍼레이션의 경우에는 private 설정을 할 수 있다.
4. 객체 외부에서 속성에 접근할 수 없다는 문제점이 발생한다.
5. 모두 public으로 공개하면 객체 무결성을 보장할 수 없기 때문이다.
6. 속성의 유효성이 지켜지지 않는 경우가 발생하여 객체 무결성이 보장되지 않을 수 있다.
7. 캡슐화는 수정 대상이 되는 특정 객체만 수정하게 하여 유지보수성을 높이고, 정보 은닉은 속성의 이름이나 데이터 타입 등을 변경했을 때 오퍼레이션만 수정하면 되므로 유지보수성을 높인다.

---

## 5장

1. 유사점은 두 정의 모두 속성과 오퍼레이션을 정의한다는 것이다. 차이점은 '객체 생성을 위한 템플릿으로서의 클래스'는 객체를 만들어서 사용하기 위한 것이고, '사용자 정의 데이터 타입으로서의 클래스'는 데이터 타입으로 사용하기 위한 것으로 객체와는 조금 다르다.
2. 클래스가 집합이라면, 객체는 클래스에 속한 것이다.

    ```java
    //이것이 클래스이다.
    class Line {
    	int x1, x2, y1, y2;
    }

    //그리고 객체는 이렇게 나타낼 수 있다.
    Line L1;
    ```

3. 생성자는 새로운 인스턴스를 생성한다. 처음으로는 주 메모리에 인스턴스가 위치하도록 공간을 할당하고 인스턴스를 생성한다. 두 번째로는 생성된 인스턴스의 상태를 초기화한다.
4. `C++에서 인스턴스를 생성하는 2가지 방법을 작성하고, 각 차이점을 기술하시오.`
5. 인스턴스의 모든 자원을 반환한다. 메모리에서 인스턴스를 삭제하고 메모리가 반환된다.
6. finalize()를 이용하여 소멸자와 유사한 기능을 구현할 수 있다.

    ```java
    public class Line {
    	private Point points[]

    	public Line(Point p1, Point p2) {
    		points = new Point[] {p1, p2};
    	}
    	
    	public static void main(String [] args) {
    		Point p1 = new Point(0, 0);
    		Point p2 = new Point(100, 100);
    		Line L1 = new Line(p1, p2);

    		p1 = null;
    		p2 = null;
    		L1 = null;

    		System.gc();
    	}

    	protected void finalize() throws Throwable {
    		super.finalize();
    		points = null;
    		System.out.println("finalize() is invoked!");
    }
    ```

7. 메시지를 작성할 때, 수신 객체의 이름 없이 메소드 이름만 작성할 경우 어떤 문제가 발생하는가?
8. `강한 포함 관계와 약한 포함 관계의 유사점과 차이점을 작성하고, 각각에 대한 예제를 Java 또는 C++로 작성하시오.`
9. Public은 여러 개의 객체가 저마다 다른 상태를 갖지만, Static은 클래스 자체에 생성되어 여러 개의 객체라도 같은 상태를 갖는다.
10. `Static 속성 및 메소드를 사용하는 적절한 예시를 찾고, 이를 Java 또는 C++로 작성하시오.`

---