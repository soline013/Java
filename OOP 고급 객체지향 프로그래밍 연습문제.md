## 1장

1. 소프트웨어 복잡도로 머신러닝과 같은 방법 등이 보편화되고 있다, 높은 비용으로 개발 비용 등이 높아지고 있다.
2. 80년대에는 객체지향 프로그래밍이 보급되었고, 90년대에 객체 지향 분석 및 설계가 개발되었다.
3. 1
4. 1
5. 1
6. 1
7. 1
8. 1
9. 1
10. 1

---

## 2장

1. 1
2. 속성 처리에 필요한 오퍼레이션을 내부에 포함하면서 독립성이 높고 복잡한 프로그램도 객체 단위로 나누어 개발할 수 있다.
3. 속성의 값이 변경되면 객체의 상태도 변경된다.
4. 대부분의 객체 속성은 그 객체의 기능성에 의해서만 처리된다.
5. 한 프로그램 세션 동안 유효하다, 세션이 종료되면 식별자가 모든 상태 정보와 같이 사라진다.
6. 1
7. 1
8. 1
9. 물리적 객체가 더 많다. 대부분 물리적 객체를 여러 개 사용하여 처리한 결과가 개념적 객체에 저장되기 때문이다.

---

## 3장

1. 1
2. 1
3. 1
4. 1
5. 1
6. Getter, Setter는 감추어진 속성에 간접적으로 접근할 때 사용한다. `private int x;`

    데이터 처리의 CRUD는 어떤 속성/데이터에 대한 처리에서 사용한다. `PhoneNumber`

    비즈니스 고유의 오퍼레이션은 그 객체 고유의 기능을 처리한다. `Car Rental System에서 checkOutCar();`

    객체의 생명주기 처리 오퍼레이션은 객체를 생성하고, 삭제하고, 미들웨어에서 인스턴스를 관리한다.

    객체의 영구성 관리 오퍼레이션은 데이터베이스에 접근하여 객체의 상태를 저장하고, 객체를 불러온다.

7. 1
8. 관련 속성과 오퍼레이션을 한 캡슐에 잘 보관하면, 수정 대상이 되는 특정 객체만 수정하면 되기 때문이다.

---

## 4장

1. 오퍼레이션을 public으로 공개해야 속성에 접근하여 속성을 변경할 수 있기 때문이다. 또한 오퍼레이션을 public으로 공개하여도 내부 알고리즘과 코드는 노출되지 않는다.
2. 객체의 속성값에 유효성 문제가 전혀 없을 것이라 생각하는 경우이다.
3. 객체 내부에서만 사용하는 오퍼레이션의 경우에는 private 설정을 할 수 있다.
4. 객체 외부에서 속성에 접근할 수 없다는 문제점이 발생한다.
5. 모두 public으로 공개하면 객체 무결성을 보장할 수 없기 때문이다.
6. 속성의 유효성이 지켜지지 않는 경우가 발생하여 객체 무결성이 보장되지 않을 수 있다.
7. 캡슐화는 수정 대상이 되는 특정 객체만 수정하게 하여 유지보수성을 높이고, 정보 은닉은 속성의 이름이나 데이터 타입 등을 변경했을 때 오퍼레이션만 수정하면 되므로 유지보수성을 높인다.